{"pages":[],"posts":[{"title":"개인용 (디지털오션)Digitalocean kubernetes 만들기","text":"개인용 Kubernetes를 가지고 싶었다. 환경이 갖춰져 있다면 개인 프로젝트 들을 쉽게 배포하고 체계적으로 관리할 수 있으며 새로운 것을 만들어서 올려보고 싶은 동기가 더 커질 것이라 생각했다. 또한 자연스럽게 kubernetes 와 더 친해지게 된다. “스타트업조차도 kubernetes를 쓰는 건 overengineering이라는 말이 있던데 개인용으로 kubernetes를 쓴다고?” 라는 의문이 생길 수도 있을 것이다. 그러나 우리는 서비스 유지 가성비를 따지는 기업이 아니다. 개인 성장을 ‘가성비’에 포함한다면 절대 overengineering 이 아니다. 어떻게 kubernetes를 만들까 고민하다가 선택한 게 바로 Digitalocean kubernetes(이하 ‘DOKS’)이다. 개인이 사용하기에도 합당한 만큼 저렴하며 ‘관리형’이라서 사용하는 데에만 집중할 수 있다. 다른 업체의 관리형 kubernetes는 굉장히 비싸다. 개인이 사용하기 부담스러울 정도의 가격이다. 이 글에서는 DOKS에 대한 설명과 내부 Service를 Domain에 연결하는 것까지 다룰 것이다. kubernetes에 대한 기본적인 지식이 있다고 가정한 글이기 때문에 kubernetes를 모른다면 공식문서를 참고하자 관리형 Kubernetes 란? 관리형이란 위 Kubernetes 요소 중 ‘Kubernetes Control Plane’ 부분 전체를 Cloud 업체에서 관리해 주는 것이고 우리는 Kubernetes Nodes 부분만 신경 쓰면 된다. Node는 Cloud 업체에서 제공하는 virtual machine을 이용하게 된다. kubernetes 버전 업데이트도 해주기 때문에 굉장히 편하다. 관리형을 사용하지 않으면 Control Plane 부분도 직접 다 세팅하고 관리해야 한다. 그러면 고려할게 배 이상으로 많아지게 되는데 그것을 다 숙지하고 관리해 나가기가 어렵다. 예를 들어 ‘etcd’ 같은 경우 분산 합의 알고리즘을 사용하고 있기 때문에 홀수로 띄워야 하며 ‘*-controller-manager, kube-scheduler’는 하나만 선별되어 동작하는 ‘리더’라는 개념이 있는 등 ‘Nodes’ 에 비해서 복잡하기에 이 모든 것들을 Cloud 업체에서 제공해 주는 것이다. 왜 관리형을 선택했나?Control Plane까지 다 구축해서 사용하는 방법도 있을 것이다. 그러나 구조 이해 용도로 한 번 직접 구축해보는 것은 좋지만 거기 까지다. 난 그걸 계속 운영해 나갈 정도의 필요성을 느끼지 못했다. 관리형 kubernetes 가 적절한 타협점이었다. 그리고 이제 돈 때문에 ‘관리형’을 선택하지 않을 이유도 없다. DOKS 가 굉장히 저렴하기 때문이다. Digitalocean 에서 kubernetes를 발표!Digitalocean 은 굉장히 유명한 클라우드 컴퓨팅 업체이다. 가성비가 굉장히 뛰어나서 개발자들이 개인용으로도 많이 이용한다. 난 2016년부터 Ubuntu를 하나 사용하고 있었다. 언제부터 인가 Digitalocean에서 ‘kubernetes’ 서비스를 준비한다는 소식이 들려왔고 난 Digitalocean의 착한 가격을 믿고 있었기에 기대하고 있었다. 그러다가 드디어 2019년 5월 21일에 일반적으로 사용이 가능하다고 발표가 되었다. 관리형 kubernetes 시장에 새로운 얼굴이 등장한 것이다. 2020년이 되어서 사용해 보았는데 이럴 수가?! 타 업체들에 비해서 너무 저렴한 것이다. 바로 기존에 관리하던 사이트를 DOKS로 옮기고 기존 VM 은 폐기하였다. 타사와 비교관리형 kubernetes 종류 Digitalocean의 DOKS (DigitalOcean Kubernetes) Node 로 Droplets를 사용한다. Amazon의 EKS (Elastic Kubernetes Service) Node 로 EC2를 사용한다. 현재 회사에서 사용하고 있다. Google의 GKE (Google Kubernetes Engine) Node 로 GCE를 사용한다. Microsoft의 AKS (Azure Kubernetes Service) Node 로 Azure VM을 사용한다. 가격 비교DOKS는 가장 낮은 Node를 두 개 선택하면 $20(월)로 사용할 수 있다. Node를 하나만 세팅이 가능하나 kubernetes 답지 못하며 Digitalocean에서도 Recommended: A minimum of 2 nodes is required to prevent downtime during upgrades or maintenance. 라고 경고가 뜬다. (리소스가 많이 필요하지 않고 downtime 이 발생해도 상관없다면 1개만 띄워도 된다. 그럼 $10(월)로 사용할 수 있다.) 다른 Cloud 업체들도 최대한 제일 낮으면서 비슷한 사양으로 비교했다. EKS, GKS, AKS 모두 (Seoul region) 기반 가격이다. (돈 단위 : USD) 클러스터 유지비 (월) 노드 (vCPU/Memory) 노드 X 2 유지비 (월) 총 유지비 (월) DOKS Free No name (1,2GiB) 10X2=20 20 EKS 73 t2.small (1,2GiB) 21.09X2=42.18 115.18 GKE 73 n1-standard-1 (1,3.75GiB) 31.17X2=62.34 135.34 AKS Free D1 v2 (1,3.5GiB) 60.23X2=120.46 120.46 가격 차이가 굉장히 크다. 혼자서 사용하는데 월 10만원 이상은 좀 부담스럽다. 실제로 직장 동료 중 EKS를 공부용으로 사용했다가 많은 돈이 청구되신 분도 있다. 타사들의 관리형 Kubernetes는 사실상 기업 전용이라고 생각한다. 가격차이가 나는 이유는 그만큼 연계되어 제공해 주는 서비스가 많아서 그렇다고 생각한다. 그렇지만 개인은 DOKS로 충분하다. Digitalocean 도 개인이 필요할 만한 서비스는 충분히 갖추고 있기 때문이다. 타당한 가격인가?월 20 달러도 크게 느껴질 수도 있다. 어쨌든 우리가 토이 프로젝트를 띄우거나 사이트를 올리려면 서버는 필요할 것이며 VM에 지불하는 돈이 나갈 것이다. 서버 환경에 대한 문제로 프로젝트에 따라서 여러 VM이 필요해질 수도 있다. $10(월) 짜리 VM 두 개만 생겨도 가격이 똑같다. 각각의 VM은 자원을 공유하지 못하며 서로 노는 자원이 발생할 것이다. 그러나 Kubernetes를 사용한다면 환경 충돌 걱정 없이 서버 자원을 공유하고 Kubernetes의 장점들은 온전히 사용할 수 있다. DOKS는 ‘persistent volume’도 Digitalocean Volumne 을 통해 간단하게 지원하기 때문에 나는 DB도 모두 하나의 DOKS로 관리하고 있다. DOKS 생성하기회원가입추천인 링크로 들어가서 가입을 하시면 결제수단을 등록했을 때 60일 동안 사용할 수 있는 $100를 받을 수 있습니다. 만약 추가로 $25이상 사용하신다면 저도 $25를 받게 됩니다. 추천인 제도에 대한 자세한 설명입니다 $100라면 두 달 동안 마음껏 사용하실 수 있습니다. cluster 생성하기 로그인을 하면 보이는 오른쪽 상단에 ‘Create’ 버튼을 통해 cluster 생성 페이지로 이동한다. 생성 페이지로 가면 처음에 버전을 선택하게 되는데 특별한 경우가 아니면 이미 선택되어 있는 latest 버전을 사용하도록 하자. region 은 San Francisco 2 로 선택하자 현재 한국에서 가장 빠르다. 여기서 region 별 속도 테스트를 직접 해볼 수 있다. Node를 결정하는 부분이다. 월 $10짜리 2개로 맞추자. cluster 가 만들어지고 나서도 언제든 바꿀 수 있다. 마음에 드는 이름으로 변경하고 ‘Create Cluster’를 눌러주자. 나는 ‘create-digitalocean-kubernetes’로 했다. 5분 정도 기다리면 kubernetes cluster 가 만들어진다. Kubernetes 생성은 이제 끝났다. (벌써..?) Digitalocean 은 Cluster 별로 ‘Kubernetes Dashboard’를 제공한다. 우리의 kubernetes 자원을 이용하여 띄우는 게 아니고 별도로 띄워준다. 즉 우리는 Kubernetes Dashboard에 대해 사용료를 지불하지 않는다. (Digitalocean 사랑합니다..) 오른쪽 상단에 ‘Kubernetes Dashboard’를 클릭해보자. 우리의 kubernetes Dashboard 화면이다. command line 을 통해서가 아니더라도 여기서 많은 정보들을 확인할 수 있다. Kubernetes Dashboard에 대한 자세한 정보는 여기를 확인해보자. DOKS 사용하기이제 환경이 갖춰졌다. San Francisco에 나만의 Kubernetes 가 돌아가고 있는 것이다. 든든하다. 이제 내부에 서버를 띄워 밖으로 연결하는 작업을 해볼 것이다. kubectl 연결하기자신의 컴퓨터에서 Kubernetes를 조작하려면 연결이 필요하다. kubectl 을 사용할 것이다. kubectl 은 Kubernetes command-line tool이다. shell$ brew install kubectl mac 을 사용한다면 위와 같이 brew를 통해 간단하게 설치가 가능하다. 그 외 OS는 여기를 보고 설치를 하자 자신의 kubernetes cluster 페이지에 보면 ‘Download Config File’버튼이 있다. 버튼을 눌러 local에 다운받자 shell$ mv ~/Downloads/create-digitalocean-kubernetes-kubeconfig.yaml ~/.kube/config 다운로드한 파일을 해당 위치로 이름을 바꾸며 옮기자 옮겨지면 kubectl 이 자동으로 설정을 인지할 것이다. shell$ kubectl config view OutputapiVersion: v1clusters:- cluster: certificate-authority-data: DATA+OMITTED server: https://d6acccc2-1275-4437-82b1-85af2728d9d9.k8s.ondigitalocean.com name: do-sfo2-create-digitalocean-kubernetescontexts:- context: cluster: do-sfo2-create-digitalocean-kubernetes user: do-sfo2-create-digitalocean-kubernetes-admin name: do-sfo2-create-digitalocean-kubernetescurrent-context: do-sfo2-create-digitalocean-kuberneteskind: Configpreferences: {}users:- name: do-sfo2-create-digitalocean-kubernetes-admin user: token: **** kubectl에 설정이 잘 적용된 것을 볼 수 있다. 이제 kubernetes를 컨트롤할 수 있는 환경이 갖춰졌다. Deployment, Service 생성하기주어진 text를 출력해 주는 hashicorp/http-echo라는 아주 간단한 이미지를 kubernetes에 띄워보자. hello-first.yamlview raw123456789101112131415161718192021222324252627282930313233apiVersion: v1kind: Servicemetadata: name: hello-firstspec: type: ClusterIP ports: - port: 80 targetPort: 5678 selector: app: hello-first---apiVersion: apps/v1kind: Deploymentmetadata: name: hello-firstspec: replicas: 1 selector: matchLabels: app: hello-first template: metadata: labels: app: hello-first spec: containers: - name: hello-first image: hashicorp/http-echo args: - \"-text=Hello from the first deployment!\" ports: - containerPort: 5678 hello-second.yamlview raw123456789101112131415161718192021222324252627282930313233apiVersion: v1kind: Servicemetadata: name: hello-secondspec: type: ClusterIP ports: - port: 80 targetPort: 5678 selector: app: hello-second---apiVersion: apps/v1kind: Deploymentmetadata: name: hello-secondspec: replicas: 1 selector: matchLabels: app: hello-second template: metadata: labels: app: hello-second spec: containers: - name: hello-second image: hashicorp/http-echo args: - \"-text=Hello from the second deployment!\" ports: - containerPort: 5678 추후 routing 테스트를 위하여 두 개의 Deployment를 작성하였다. hello-first는 ‘Hello from the first deployment!’로 hello-second는 ‘Hello from the second deployment!’로 각기 다른 text를 출력해 줄 것이다. shell$ kubectl apply -f hello-first.yaml -f hello-second.yaml Outputservice/hello-first createddeployment.apps/hello-first createdservice/hello-second createddeployment.apps/hello-second created kubectl apply로 두 개의 파일을 kubernetes에게 만들라고 명령하였다. shell$ kubectl get pods OutputNAME READY STATUS RESTARTS AGEhello-first-b5785588f-xdhcj 1/1 Running 0 9m25shello-second-797c6c6d87-pdwpg 1/1 Running 0 9m25s 성공적으로 돌아가고 있는 것이 확인된다. 그렇지만 아직 밖에서 접근을 못하는 상황이다. DOKS는 Load Balancer를 통해서 외부와 통신할 수 있다. Service마다 Load Balancer를 바로 연결할 수 있지만 개당 가격이 월 $10이기 때문에 서비스마다 연결하기엔 가격이 부담스럽다. nginx-ingress 설치하기nginx-ingress를 사용하면 Load Balancer를 하나만 만들고 트래픽 라우팅을 통해 여러 Service를 연결할 수 있다. nginx-ingress를 간단하게 설치하고 관리하려면 helm 이 필요하다. helm 은 Kubernetes 용 package managing tool이다. python에 pip, javascript에 npm 과 비슷하다고 생각하면 된다. shell$ brew install helm mac 을 사용한다면 위와 같이 brew를 통해 간단하게 설치가 가능하다. 그 외 OS는 여기를 보고 설치를 하자. 설치를 완료하면 helm 은 kubectl 과 같은 설정을 사용하기 때문에 자동으로 kubernetes 와 연결이 된다. shell$ helm install nginx-ingress stable/nginx-ingress --set controller.publishService.enabled=true$ helm list OutputNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSIONnginx-ingress default 1 2020-03-22 15:57:24.358441 +0900 KST deployed nginx-ingress-1.33.0 0.30.0 helm install로 nginx-ingress를 설치한다. controller.publishService.enabled 옵션을 통해 Load Balancer를 자동으로 만들어 줄 수 있다. 설치 후 helm list로 확인해보면 0.30 버전으로 잘 설치되어 있다. shell$ kubectl get services -w nginx-ingress-controller OutputNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEnginx-ingress-controller LoadBalancer 10.245.202.210 157.230.197.35 80:32019/TCP,443:31635/TCP 4m34s get service에 -w (watch) 옵션을 더해 nginx-ingress-controller를 관찰하고 있자. EXTERNAL-IP 가 비어있다가 생기는 것을 확인할 수 있을 것이다. Load Balancer를 발급받는 과정이다. 이제 EXTERNAL-IP에 나와있는 IP로 Kubernetes 내부에 접근이 가능하다. digitalocean에 들어가 보면 Load Balancer 하나가 만들어져있다. IP Address를 보면 kubectl로 보았던 EXTERNAL-IP 와 똑같은 것을 확인할 수 있다. (하단에 21일 전에 만들어진 Load Balancer는 기존에 내가 사용하고 있는 것이다.) nginx-ingress 경로 기반 라우팅hello-ingress-path.yamlview raw123456789101112131415161718apiVersion: extensions/v1beta1kind: Ingressmetadata: name: hello-ingress annotations: kubernetes.io/ingress.class: nginxspec: rules: - http: paths: - path: /first backend: serviceName: hello-first servicePort: 80 - path: /second backend: serviceName: hello-second servicePort: 80 shell$ kubectl apply -f hello-ingress-path.yaml Outputingress.extensions/hello-ingress created ingress yaml 파일을 작성하여 kubernetes에 적용시켜준다. path로 라우팅 되며 ‘/first’는 아까 만든 hello-first로 ‘/second’는 hello-second로 연결해 준다. 발급받은 Load Balancer IP 로 뒤에 path를 붙여서 접근해보자. 하나의 Load Balancer로 두 개의 Service를 서빙하고 있는 것을 확인할 수 있다. 이제 어떤 서비스든 외부에서 접근을 할 수 있게 되었다. nginx-ingress 도메인 기반 라우팅도메인을 가지고 있다면 도메인을 통해 라우팅이 가능하다. 몇 개의 도메인이든 연결이 가능하며 나는 2개의 도메인을 각각의 service에 연결해 보겠다. 먼저 Load Balancer IP로 도메인들을 연결해 준다. hello-ingress-host.yamlview raw1234567891011121314151617181920apiVersion: extensions/v1beta1kind: Ingressmetadata: name: hello-ingress annotations: kubernetes.io/ingress.class: nginxspec: rules: - host: first.zunik.me http: paths: - backend: serviceName: hello-first servicePort: 80 - host: second.zunik.me http: paths: - backend: serviceName: hello-second servicePort: 80 shell$ kubectl apply -f hello-ingress-host.yaml 각각의 도메인에 따라서 다른 Service로 보내주도록 ingress files 을 변경해 주고 적용한다. 도메인으로 잘 연결되는 것을 확인할 수 있다. 또한 (경로, 도메인) 기반은 혼합해서도 얼마든지 사용이 가능하다. 정리하기모든 연습이 끝났다면 관련 자원을 모두 정리하자. shell$ kubectl delete -f hello-first.yaml -f hello-second.yaml -f hello-ingress-host.yaml Outputservice &quot;hello-first&quot; deleteddeployment.apps &quot;hello-first&quot; deletedservice &quot;hello-second&quot; deleteddeployment.apps &quot;hello-second&quot; deletedingress.extensions &quot;hello-ingress&quot; deleted nginx-ingress 와 Load Balancer는 그대로 있기에 여기 기반에서 뭐든 올려서 사용할 수 있을 것이다. 마지막으로이제 우리에게 개인용 kubernetes cluster 가 생겼다. Load Balancer까지 붙인다면 월 $30가 들기 때문에 이 친구는 우리에게 얼른 뭐든 올려달라고, 무슨 토이 프로젝트든 시작하라고 자극하고 동기를 부여할 것이다. 이런 장치들을 많이 마련해 놔야 우리가 계속 움직일 수 있지 않을까?","link":"/2020/03/22/create-digitalocean-kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"digitalocean","slug":"digitalocean","link":"/tags/digitalocean/"}],"categories":[{"name":"tech","slug":"tech","link":"/categories/tech/"},{"name":"kubernetes","slug":"tech/kubernetes","link":"/categories/tech/kubernetes/"}]}